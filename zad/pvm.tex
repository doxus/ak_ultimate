% !TeX spellcheck = pl_PL
\newpage
\section{PVM}
	\subsection{Wstęp z laborek, szukanie min i max}
		\subsubsection{Treść}
			Napisać program znajdujący minimum i maksimum z macierzy.\\
			Hello.c - program główny, rodzic; Hello\_other.c - program podrzędny, potomek.
		\subsubsection{Rozwiązanie}
			Program przekazuje kolejne wiersze macierzy do programów potomnych, które znajdują lokalne minimum i maksimum. Program zbiera wszystkie minima i maksima do tablicy o rozmiarze wysokości macierzy. Pod koniec sam ręcznie wylicza min i max z tych dwóch tablic.\\
			Należy pamiętać, że programy potomne muszą fizycznie znajdować się na dyskach innych komputerów w sieci PVM.\\
			\textbf{Program działający, oceniony na 5.}
			\begin{lstlisting}[language={C}]
				/* - Autorzy:
				   -- Forczu Forczmański
				   -- Wuda Wudecki
				*/
				#include <stdio.h>
				#include <stdlib.h>
				#include <math.h>
				#include "pvm3.h"
				#define WYSOKOSC 5		// liczba wierszy
				#define SZEROKOSC 5		// liczba kolumn
				/// Program rodzica
				main()
				{
					// dane potrzebne do obliczeń
					int matrix[WYSOKOSC][SZEROKOSC];
					int min_result[WYSOKOSC], max_result[WYSOKOSC];
					int minimum, maksimum;
					// wypełnienie macierzy danymi
					int i, j;
					for ( i = 0; i < WYSOKOSC; ++i )
						for ( j = 0; j < SZEROKOSC; ++j)
							matrix[i][j] = rand() % 30;
					// wypisanie macierzy na konsoli
					for ( i = 0; i < WYSOKOSC; ++i )
					{
						for ( j = 0; j < SZEROKOSC; ++j)
							printf("%d ", matrix[i][j]);
						printf("\n\n");
					}
					// pobranie informacji
					int ilhost, ilarch;
					struct pvmhostinfo * info;
					pvm_config(&ilhost, &ilarch, &info);
					printf("Liczba hostow: %d\n", ilhost);
					
					int id1 = 0;
					int tid;
					
					
					
					// Dla każdego hosta - inicjujemy go
					for ( i = 0; i < ilhost; i++ )
					{
						pvm_spawn( "/home/pvm/pvm3/sekcja11/bin/LINUX/hello_other", 0, PvmTaskHost, info[i].hi_name, 1, &tid);
						if ( tid < 0 )
						{
							ilhost--;
							continue;
						}
						printf("tid: %d\n", tid);
						pvm_initsend(PvmDataDefault);
						// wysyłamy:
						// id wiersza
						pvm_pkint(&id1, 1, 1);
						// elementy wiersza
						pvm_pkint(&matrix[id1][0], SZEROKOSC, 1);
						pvm_send(tid, 100);
						id1++;
					}
					//// Wykonywanie programu aż do przedostatniej pętli
					int bufid, child_tid, child_id1, tmp;
					while ( id1 < WYSOKOSC )
					{
						bufid = pvm_recv(-1, 200);
						pvm_bufinfo(bufid, &tmp, &tmp, &child_tid);
						printf("recv: %d\n", child_tid);
						// pobranie id wiersza
						pvm_upkint(&child_id1, 1, 1);
						// pobranie nowych min / max
						pvm_upkint(&min_result[child_id1], 1, 1);
						pvm_upkint(&max_result[child_id1], 1, 1);
						// wysłanie nowych danych
						pvm_initsend(PvmDataDefault);
						// id kolejnego wiersza
						pvm_pkint(&id1, 1, 1);
						// nowy wiersz
						pvm_pkint(&matrix[id1][0], SZEROKOSC, 1);
						pvm_send(child_tid, 100);
						id1++;
					}
					//// Odebranie ostatnich danych
					for	(i = 0; i < id1 - ilhost + 1; i++ )
					{
						bufid = pvm_recv(-1, 200);
						pvm_bufinfo(bufid, &tmp, &tmp, &child_tid);
						printf("recv: %d\n", child_tid);
						// pobranie id wiersza
						pvm_upkint(&child_id1, 1, 1);
						// pobranie nowych min / max
						pvm_upkint(&min_result[child_id1], 1, 1);
						pvm_upkint(&max_result[child_id1], 1, 1);
					}
					
					
					
					
					// uzysaknie minimum z wiersza
					minimum = min_result[0];
					maksimum = max_result[0];
					for (j = 1; j < WYSOKOSC; j++)
					{
						if ( max_result[j] > maksimum )
							maksimum = max_result[j];
						if ( min_result[j] < minimum )
							minimum = min_result[j];
					}
					printf("Uzyskane wartosci:\nMIN: %d, MAX: %d\n", minimum, maksimum);
					pvm_exit();
					return 0;
				}
			\end{lstlisting}
			\textbf{Program potomka}
			\begin{lstlisting}[language={C}]
				#include <stdio.h>
				#include <math.h>
				#include "pvm3.h"
				#define WYSOKOSC 5		// liczba wierszy
				#define SZEROKOSC 5		// liczba kolumn
				/// Program potomka
				int main()
				{
					int masterid, id1, j, curr_row[SZEROKOSC], curr_min, curr_max;
					// pobierz id rodzica 
					masterid = pvm_parent();
					if (masterid == 0)
						exit(1);
					while(1)
					{
						pvm_recv(masterid, 100);
						// pobranie wartości:
						// id wiersza
						pvm_upkint(&id1, 1, 1);
						pvm_upkint(&curr_row[0], SZEROKOSC, 1);
						// uzysaknie minimum z wiersza
						curr_min = curr_max = curr_row[0];
						for (j = 1; j < SZEROKOSC; j++)
						{
							if ( curr_row[j] > curr_max )
								curr_max = curr_row[j];
							if ( curr_row[j] < curr_min )
								curr_min = curr_row[j];
						}
						// wysłanie nowych danych
						pvm_initsend(PvmDataDefault);
						pvm_pkint(&id1, 1, 1);
						pvm_pkint(&curr_min, 1, 1);
						pvm_pkint(&curr_max, 1, 1);
						pvm_send(masterid, 200);
					}
					pvm_exit();
					return 0;
				}
			\end{lstlisting}
	\subsection{Laborki, odejmowanie macierzy}
		\subsubsection{Treść}
			Odejmowanie macierzy.
		\subsubsection{Rozwiązanie}
			Ocena nieznana.
			\begin{lstlisting}[language=C]
				/* AK Lab 2 - PVM
					Anna Kusnierz
					Tomasz Szoltysek
					Temat: Odejmowanie dwoch macierzy
				*/
				#include <stdio.h>
				#include <math.h>
				#include "pvm3.h"
				#define MATRIX_SIZE 20
				int main() 
				{
					int i,j;
					int count = 0; 		//licznik wierszy macierzy
					int rescount;
					int tidmaster, ilhost, ilarch, bufid,t_id,bytes,msgtag;
					struct pvmhostinfo info;
					
					int a[MATRIX_SIZE][MATRIX_SIZE], b[MATRIX_SIZE][MATRIX_SIZE], r[MATRIX_SIZE][MATRIX_SIZE];
					FILE *txt = fopen("result.txt","w");
					
					for(i=0;i<MATRIX_SIZE;i++)
					{
						for(j=0;j<MATRIX_SIZE;j++)
						{
							a[i][j] = rand();
							b[i][j] = rand();
						}
					}
					fprintf(txt,"Macierz A:\n--------------------------------------------------\n\n");
					for(i=0;i<MATRIX_SIZE;i++)
					{
						for(j=0;j<MATRIX_SIZE;j++)
							fprintf(txt,"%d\t",a[i][j]);
						fprintf(txt,"\n");
					}
					fprintf(txt,"Macierz B:\n--------------------------------------------------\n\n");
					for(i=0; i<MATRIX_SIZE;i++)
					{
						for(j=0;j<MATRIX_SIZE;j++)
							fprintf(txt,"%d\t",b[i][j]);
						fprintf(txt,"\n");
					}
					
					
					
					tidmaster = pvm_mytid();
					pvm_config(&ilhost, &ilarch, &info);
					printf("%d",ilhost);
					for(i=0; i < (ilhost > MATRIX_SIZE ? MATRIX_SIZE : ilhost) ;i++)
					{
						pvm_spawn("/home/pvm3/pvm3/sekcja4/hello_other",0,PvmTaskHost,info[i].hi_name,1,&t_id);
						pvm_initsend(PvmDataDefault);
						pvm_pkint(&a[count][0],MATRIX_SIZE,1);
						pvm_pkint(&b[count][0],MATRIX_SIZE,1);
						pvm_pkint(&count,1,1);
						pvm_send(t_id,100);	
						++count;
					}
					while(count<MATRIX_SIZE)
					{
						bufid = pvm_recv(-1,200);
						pvm_bufinfo(bufid,&bytes,&msgtag,&t_id);
						pvm_upkint(&rescount,1,1);
						pvm_upkint(&r[rescount][0],MATRIX_SIZE,1);
						pvm_initsend(PvmDataDefault);
						pvm_pkint(&a[count][0],MATRIX_SIZE,1);
						pvm_pkint(&b[count][0],MATRIX_SIZE,1);
						pvm_pkint(&count,1,1);
						pvm_send(t_id,100);
						++count;
					}
					for(i = 0; i < (ilhost > MATRIX_SIZE ? MATRIX_SIZE : ilhost); i++)
					{
						bufid = pvm_recv(-1,200);
						pvm_bufinfo(bufid,&bytes,&msgtag,&t_id);
						pvm_upkint(&rescount,1,1);
						pvm_upkint(&r[rescount][0],MATRIX_SIZE,1);
						pvm_kill(t_id);	
					}
					fprintf(txt,"Macierz wynikowa:\n--------------------------------------------------\n\n");
					for(i=0; i<MATRIX_SIZE;i++)
					{
						for(j=0;j<MATRIX_SIZE;j++)
							fprintf(txt,"%d\t",r[i][j]);
						fprintf(txt,"\n");
					}
					fclose(txt);
					exit(0);
				}
			\end{lstlisting}
			\newpage
			\textbf{Program potomny}
			\begin{lstlisting}[language=C]
				#include <stdio.h>
				#include "pvm3.h"
				#define MATRIX_SIZE 20
				int main()
				{
					int masterid, count, i;
					double vecta[MATRIX_SIZE],vectb[MATRIX_SIZE],vectr[MATRIX_SIZE];
					masterid = pvm_parent();
					if(masterid == 0) exit(1);	//zabezpieczenie przed uruchomieniem z poziomu rodzica
					//OBSŁUGA OBLICZEŃ i WYSYŁANIA WYNIKÓW
					while(1)
					{
						pvm_recv(masterid,100);
						pvm_upkdouble(&vecta[0],MATRIX_SIZE,1);
						pvm_upkdouble(&vectb[0],MATRIX_SIZE,1);
						pvm_upkint(&count,1,1);
						for(i = 0; i < MATRIX_SIZE; i++)
							vectr[i] = vecta[i] - vectb[i];
						pvm_initsend(PvmDataDefault);
						pvm_pkint(&count,1,1);
						pvm_pkdouble(&vectr[0],MATRIX_SIZE,1);
						pvm_send(masterid,200);		
					}
					return(0);
				}
			\end{lstlisting}
			