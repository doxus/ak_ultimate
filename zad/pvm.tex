% !TeX spellcheck = pl_PL
\newpage
\section{PVM}
		\subsection{Laborki, min max z macierzy}
		Program przekazuje kolejne wiersze macierzy do programów potomnych, które znajdują lokalne minimum i maksimum. Program zbiera wszystkie minima i maksima do tablicy o rozmiarze wysokości macierzy. Pod koniec sam ręcznie wylicza min i max z tych dwóch tablic.\\
		Należy pamiętać, że programy potomne muszą fizycznie znajdować się na dyskach innych komputerów w sieci PVM.\\
			\begin{lstlisting}[language={C}]
				/* - Autorzy:
				   -- Forczu Forczmański
				   -- Wuda Wudecki
				*/
				#include <stdio.h>
				#include <stdlib.h>
				#include <math.h>
				#include "pvm3.h"
				#define WYSOKOSC 5		// liczba wierszy
				#define SZEROKOSC 5		// liczba kolumn
				/// Program rodzica
				main()
				{
					// dane potrzebne do obliczeń
					int matrix[WYSOKOSC][SZEROKOSC];
					int min_result[WYSOKOSC], max_result[WYSOKOSC];
					int minimum, maksimum;
					// wypełnienie macierzy danymi
					int i, j;
					for ( i = 0; i < WYSOKOSC; ++i )
						for ( j = 0; j < SZEROKOSC; ++j)
							matrix[i][j] = rand() % 30;
					// wypisanie macierzy na konsoli
					for ( i = 0; i < WYSOKOSC; ++i )
					{
						for ( j = 0; j < SZEROKOSC; ++j)
							printf("%d ", matrix[i][j]);
						printf("\n\n");
					}
					// pobranie informacji
					int ilhost, ilarch;
					struct pvmhostinfo * info;
					pvm_config(&ilhost, &ilarch, &info);
					printf("Liczba hostow: %d\n", ilhost);
					
					int id1 = 0;
					int tid;
				\end{lstlisting}
				\newpage
				\begin{lstlisting}[language={C}]
					// Dla każdego hosta - inicjujemy go
					for ( i = 0; i < ilhost; i++ )
					{
						pvm_spawn( "/home/pvm/pvm3/sekcja11/bin/LINUX/hello_other", 0, PvmTaskHost, info[i].hi_name, 1, &tid);
						if ( tid < 0 )
						{
							ilhost--;
							continue;
						}
						printf("tid: %d\n", tid);
						pvm_initsend(PvmDataDefault);
						// wysyłamy:
						// id wiersza
						pvm_pkint(&id1, 1, 1);
						// elementy wiersza
						pvm_pkint(&matrix[id1][0], SZEROKOSC, 1);
						pvm_send(tid, 100);
						id1++;
					}
					//// Wykonywanie programu aż do przedostatniej pętli
					int bufid, child_tid, child_id1, tmp;
					while ( id1 < WYSOKOSC )
					{
						bufid = pvm_recv(-1, 200);
						pvm_bufinfo(bufid, &tmp, &tmp, &child_tid);
						printf("recv: %d\n", child_tid);
						// pobranie id wiersza
						pvm_upkint(&child_id1, 1, 1);
						// pobranie nowych min / max
						pvm_upkint(&min_result[child_id1], 1, 1);
						pvm_upkint(&max_result[child_id1], 1, 1);
						// wysłanie nowych danych
						pvm_initsend(PvmDataDefault);
						// id kolejnego wiersza
						pvm_pkint(&id1, 1, 1);
						// nowy wiersz
						pvm_pkint(&matrix[id1][0], SZEROKOSC, 1);
						pvm_send(child_tid, 100);
						id1++;
					}
					//// Odebranie ostatnich danych
					for	(i = 0; i < id1 - ilhost + 1; i++ )
					{
						bufid = pvm_recv(-1, 200);
						pvm_bufinfo(bufid, &tmp, &tmp, &child_tid);
						printf("recv: %d\n", child_tid);
						// pobranie id wiersza
						pvm_upkint(&child_id1, 1, 1);
						// pobranie nowych min / max
						pvm_upkint(&min_result[child_id1], 1, 1);
						pvm_upkint(&max_result[child_id1], 1, 1);
					}
				\end{lstlisting}
				\newpage
				\begin{lstlisting}[language={C}]
					// uzysaknie minimum z wiersza
					minimum = min_result[0];
					maksimum = max_result[0];
					for (j = 1; j < WYSOKOSC; j++)
					{
						if ( max_result[j] > maksimum )
							maksimum = max_result[j];
						if ( min_result[j] < minimum )
							minimum = min_result[j];
					}
					printf("Uzyskane wartosci:\nMIN: %d, MAX: %d\n", minimum, maksimum);
					pvm_exit();
					return 0;
				}
			\end{lstlisting}
			Program potomka
			\begin{lstlisting}[language={C}]
				#include <stdio.h>
				#include <math.h>
				#include "pvm3.h"
				#define WYSOKOSC 5		// liczba wierszy
				#define SZEROKOSC 5		// liczba kolumn
				/// Program potomka
				int main()
				{
					int masterid, id1, j, curr_row[SZEROKOSC], curr_min, curr_max;
					// pobierz id rodzica 
					masterid = pvm_parent();
					if (masterid == 0)
						exit(1);
					while(1)
					{
						pvm_recv(masterid, 100);
						// pobranie wartości:
						// id wiersza
						pvm_upkint(&id1, 1, 1);
						pvm_upkint(&curr_row[0], SZEROKOSC, 1);
						// uzysaknie minimum z wiersza
						curr_min = curr_max = curr_row[0];
						for (j = 1; j < SZEROKOSC; j++)
						{
							if ( curr_row[j] > curr_max )
								curr_max = curr_row[j];
							if ( curr_row[j] < curr_min )
								curr_min = curr_row[j];
						}
						// wysłanie nowych danych
						pvm_initsend(PvmDataDefault);
						pvm_pkint(&id1, 1, 1);
						pvm_pkint(&curr_min, 1, 1);
						pvm_pkint(&curr_max, 1, 1);
						pvm_send(masterid, 200);
					}
					pvm_exit();
					return 0;
				}
			\end{lstlisting}
		\subsection{Laborki, odejmowanie macierzy}
		\subsubsection{Treść}
		Odejmowanie macierzy.
		\begin{lstlisting}[language=C]
		#include <stdio.h>
		#include <math.h>
		#include "pvm3.h"
		#define MATRIX_SIZE 20
		int main() 
		{
			int i,j;
			int count = 0; 		//licznik wierszy macierzy
			int rescount;
			int tidmaster, ilhost, ilarch, bufid,t_id,bytes,msgtag;
			struct pvmhostinfo info;
			
			int a[MATRIX_SIZE][MATRIX_SIZE], b[MATRIX_SIZE][MATRIX_SIZE], r[MATRIX_SIZE][MATRIX_SIZE];
			FILE *txt = fopen("result.txt","w");
			
			for(i=0;i<MATRIX_SIZE;i++)
			{
				for(j=0;j<MATRIX_SIZE;j++)
				{
					a[i][j] = rand();
					b[i][j] = rand();
				}
			}
			fprintf(txt,"Macierz A:\n--------------------------------------------------\n\n");
			for(i=0;i<MATRIX_SIZE;i++)
			{
				for(j=0;j<MATRIX_SIZE;j++)
				fprintf(txt,"%d\t",a[i][j]);
				fprintf(txt,"\n");
			}
			fprintf(txt,"Macierz B:\n--------------------------------------------------\n\n");
			for(i=0; i<MATRIX_SIZE;i++)
			{
				for(j=0;j<MATRIX_SIZE;j++)
				fprintf(txt,"%d\t",b[i][j]);
				fprintf(txt,"\n");
			}
			tidmaster = pvm_mytid();
			pvm_config(&ilhost, &ilarch, &info);
			printf("%d",ilhost);
			for(i=0; i < (ilhost > MATRIX_SIZE ? MATRIX_SIZE : ilhost) ;i++)
			{
				pvm_spawn("/home/pvm3/pvm3/sekcja4/hello_other",0,PvmTaskHost,info[i].hi_name,1,&t_id);
				pvm_initsend(PvmDataDefault);
				pvm_pkint(&a[count][0],MATRIX_SIZE,1);
				pvm_pkint(&b[count][0],MATRIX_SIZE,1);
				pvm_pkint(&count,1,1);
				pvm_send(t_id,100);	
				++count;
			}
			while(count<MATRIX_SIZE)
			{
				bufid = pvm_recv(-1,200);
				pvm_bufinfo(bufid,&bytes,&msgtag,&t_id);
				pvm_upkint(&rescount,1,1);
				pvm_upkint(&r[rescount][0],MATRIX_SIZE,1);
				pvm_initsend(PvmDataDefault);
				pvm_pkint(&a[count][0],MATRIX_SIZE,1);
				pvm_pkint(&b[count][0],MATRIX_SIZE,1);
				pvm_pkint(&count,1,1);
				pvm_send(t_id,100);
				++count;
			}
			for(i = 0; i < (ilhost > MATRIX_SIZE ? MATRIX_SIZE : ilhost); i++)
			{
				bufid = pvm_recv(-1,200);
				pvm_bufinfo(bufid,&bytes,&msgtag,&t_id);
				pvm_upkint(&rescount,1,1);
				pvm_upkint(&r[rescount][0],MATRIX_SIZE,1);
				pvm_kill(t_id);	
			}
			fprintf(txt,"Macierz wynikowa:\n--------------------------------------------------\n\n");
			for(i=0; i<MATRIX_SIZE;i++)
			{
				for(j=0;j<MATRIX_SIZE;j++)
				fprintf(txt,"%d\t",r[i][j]);
				fprintf(txt,"\n");
			}
			fclose(txt);
			exit(0);
		}
		\end{lstlisting}
		\newpage
		\textbf{Program potomny}
		\begin{lstlisting}[language=C]
		#include <stdio.h>
		#include "pvm3.h"
		#define MATRIX_SIZE 20
		int main()
		{
			int masterid, count, i;
			double vecta[MATRIX_SIZE],vectb[MATRIX_SIZE],vectr[MATRIX_SIZE];
			masterid = pvm_parent();
			if(masterid == 0) exit(1);	//zabezpieczenie przed uruchomieniem z poziomu rodzica
			//OBSŁUGA OBLICZEŃ i WYSYŁANIA WYNIKÓW
			while(1)
			{
				pvm_recv(masterid,100);
				pvm_upkdouble(&vecta[0],MATRIX_SIZE,1);
				pvm_upkdouble(&vectb[0],MATRIX_SIZE,1);
				pvm_upkint(&count,1,1);
				for(i = 0; i < MATRIX_SIZE; i++)
				vectr[i] = vecta[i] - vectb[i];
				pvm_initsend(PvmDataDefault);
				pvm_pkint(&count,1,1);
				pvm_pkdouble(&vectr[0],MATRIX_SIZE,1);
				pvm_send(masterid,200);		
			}
			return(0);
		}
		\end{lstlisting}
			
		\newpage
		\subsection{Treść}
		Tabela A zawiera 10000 łańcuchów znakowych i tabela B zawiera 10000 wartości typu int, sum kontrolnych tabeli A. Kod rodzica porównującego checksumę z łańcuchem tabeli A.
			\begin{lstlisting}[language=C]
			#include "pvm3.h"
			#include <stdio.h>
			const int RECORD_NUMBER = 10000
			void fill_tables(char* input[RECORD_NUMBER], int output[RECORD_NUMBER]);
			
			int main_pvm()
			{
				// dane wejściowe
				char* input[RECORD_NUMBER];
				int output[RECORD_NUMBER];
				// zakładamy, że ta funkcja wypełnia tablice jak należy
				fill_tables(input, output);
				// liczniki wystąpień
				unsigned int true_count = 0;
				// pobranie informacji
				int ilhost, ilarch;
				struct pvmhostinfo * info;
				pvm_config(&ilhost, &ilarch, &info);
				printf("Liczba hostow: %d\n", ilhost);
				
				int id, tid;
				id = 0;
				int i;
				// dla każdego hosta
				for (i = 0; i < ilhost; i++, id++)
				{
					pvm_spawn("/egzamin/dziecko", 0, PvmTaskHost, info[i].hi_name, 1, &tid);
					if (tid < 0)
					{
						ilhost--;
						continue;
					}
					pvm_initsend(PvmDataDefault);
					// wysyłamy:
					pvm_pkint(&id, 1, 1);			// id wiersza
					pvm_pkstr(input[id]);			// łańcuch
					pvm_pkint(&output[id], 1, 1);	// suma kontrolna
					pvm_send(tid, 100);
				}
			\end{lstlisting}
			\newpage
			\begin{lstlisting}[language=C]
			{	// ...
				int bufid, child_tid, child_id, tmp, result;
				while (id < RECORD_NUMBER)
				{
					bufid = pvm_recv(-1, 200);
					pvm_bufinfo(bufid, &tmp, &tmp, &child_tid);
					// pobranie danych
					pvm_upkint(&child_id, 1, 1);	// id wiersza
					pvm_upkint(&result, 1, 1);		// wynik
					// dziecko zwraca 0, jeśli suma nie była poprawna
					// lub 1, jeśli była poprawna
					true_count = true_count + result;
					// wysłanie nowych danych
					pvm_initsend(PvmDataDefault);
					pvm_pkint(&id, 1, 1);			// id kolejnego wiersza
					pvm_pkstr(input[id]);			// łańcuch
					pvm_pkint(&output[id], 1, 1);	// suma kontrolna
					pvm_send(child_tid, 100);
					id++;
				}
				// odbieranie ostatnich wyników od potomków
				for (i = 0; i < ilhost; i++)
				{
					bufid = pvm_recv(-1, 200);
					pvm_bufinfo(bufid, &tmp, &tmp, &child_tid);
					pvm_upkint(&child_id, 1, 1);	// pobranie id wiersza
					pvm_upkint(&result, 1, 1);		// wynik
					true_count = true_count + result;
				}
				// wypisanie wyniku
				printf("Liczba poprawnych sum kontrolnych = %d\n", true_count);
				printf("Liczba niepoprawnych sum kontrolnych = %d", RECORD_NUMBER - true_count);
				pvm_exit();
				
				return 0;
			}
			\end{lstlisting}
			\newpage
			\subsection{Treść}
			Wyliczenie silni każdego elementu tablicy T mającej 1000 elementów \textit{INT}.
			\begin{lstlisting}[language=C]
				#include "pvm3.h"
				#define ELEMENT_NUMBER 1000
				int main()
				{
					// nasza tablica
					int T[ELEMENT_NUMBER];
					int i;
					for (i = 0; i < ELEMENT_NUMBER; i++)
					T[i] = i;
					
					int ilhost, ilarch;			//parametry z PVMa
					struct pvmhostinfo * info;
					pvm_config(&ilhost, &ilarch, &info);
					
					int id_komorki = 0;
					int tid;
					// Dla każdego hosta - inicjujemy go
					for (i = 0; i < ilhost; i++)
					{
						pvm_spawn("/potomek", 0, PvmTaskHost, info[i].hi_name, 1, &tid);	//powołanie potomka
						if (tid < 0)
						{
							ilhost--;
							continue;
						}
						pvm_initsend(PvmDataDefault);
						// wysyłamy
						pvm_pkint(&T[id_komorki], 1, 1);
						pvm_send(tid, 100);
						id_komorki++;
					}
			\end{lstlisting}
			\newpage
			\begin{lstlisting}[language=C]
				{
					// Wykonywanie programu aż do przedostatniej pętli
					int bufid, child_tid, child_id_komorki, child_silnia, tmp;
					while (id_komorki < ELEMENT_NUMBER)
					{
						// odebranie info o zakończeniu pracy
						bufid = pvm_recv(-1, 200);
						pvm_bufinfo(bufid, &tmp, &tmp, &child_tid);
						// pobranie obliczonej silni
						pvm_upkint(&child_id_komorki, 1, 1);
						pvm_upkint(&child_silnia, 1, 1);
						// napisanie wartości w tablicy
						T[child_id_komorki] = child_silnia;
						// wysłanie nowych danych
						pvm_initsend(PvmDataDefault);
						pvm_pkint(&T[id_komorki], 1, 1);
						pvm_send(child_tid, 100);
						id_komorki++;
					}
					// Odebranie ostatnich danych
					for (i = 0; i < ilhost; i++)
					{
						bufid = pvm_recv(-1, 200);
						pvm_bufinfo(bufid, &tmp, &tmp, &child_tid);
						// pobranie obliczonej silni
						pvm_upkint(&child_id_komorki, 1, 1);
						pvm_upkint(&child_silnia, 1, 1);
						// napisanie wartości w tablicy
						T[child_id_komorki] = child_silnia;
					}
					pvm_exit();
					return 0;
				}
			\end{lstlisting}
			\newpage
			\subsection{Treść}
				Program przeszukuje fragment obrazu (\textit{wzorzec}) o rozmiarze $ nxn $ w obrazie \textit{Obraz} o rozmiarze $ mxm (m>>n) $. 
				Funkcja \textit{int find\_pattern(x, y, n)}, gdzie \textit{x, y} to współrzędne w obrazie, a \textit{n} rozmiar wzorca szuka danego wzorca.
				\begin{lstlisting}[language=C]
				#include "pvm3.h"
				extern int m;				// wymiar obraz
				extern int n;				// wymiar wzorca
				
				int main()
				{
					int liczbaWystapien = 0;
					// tablica pikseli, zakladamy ze tak reprezentowany jest obraz
					int obraz[m][m];		
					int ilhost, ilarch;			//parametry z PVMa
					struct pvmhostinfo * info;
					pvm_config(&ilhost, &ilarch, &info);
					printf("Liczba hostow: %d\n", ilhost);
					
					int id_wiersza = 0;
					int tid;
					// Dla każdego hosta - inicjujemy go
					for ( i = 0; i < ilhost; i++ )
					{
						//powołanie potomka
						pvm_spawn( "/potomek", 0, PvmTaskHost, info[i].hi_name, 1, &tid);
						//jeśli nie udało się powołać potomka, zmniejszamy liczbę hostów i kontynuujemy	
						if ( tid < 0 )
						{
							ilhost--;	
							continue;
						}
						pvm_initsend(PvmDataDefault);
						// wysyłamy:
						// elementy obrazu
						for (int i = 0; i < n; i++)
						{
							//pakowanie całego wiersza
							pvm_pkint(&obraz[id_wiersza + i][0], m, 1);
						}
						pvm_send(tid, 100);		//wysłanie wiersza
						id_wiersza++;
					}
				\end{lstlisting}
				\newpage
				\begin{lstlisting}[language=C]
					{ 	// ...
						// Wykonywanie programu aż do przedostatniej pętli
						int bufid, child_tid, child_liczba_wystapien, tmp;
						while ( id_wiersza < (m - n) )
						{
							// odebranie info o zakończeniu pracy
							bufid = pvm_recv(-1, 200);
							pvm_bufinfo(bufid, &tmp, &tmp, &child_tid);
							// pobranie liczby wystapien
							pvm_upkint(&child_liczba_wystapien, 1, 1);
							// zwiekszenie wystapien wzorca
							liczbaWystapien += child_liczba_wystapien;
							// wysłanie nowych danych
							pvm_initsend(PvmDataDefault);
							// nowa czesc obrazu
							for (int i = 0; i < n; i++)
							{
								pvm_pkint(&obraz[id_wiersza + i][0], m, 1);
							}
							pvm_send(child_tid, 100);
							id_wiersza++;
						}
						// Odebranie ostatnich danych
						for	(i = 0; i < id_wiersza - ilhost + 1; i++ )
						{
							bufid = pvm_recv(-1, 200);
							pvm_bufinfo(bufid, &tmp, &tmp, &child_tid);
							// pobranie liczby wystapien
							pvm_upkint(&child_liczba_wystapien, 1, 1);
							// zwiekszenie wystapien wzorca
							liczbaWystapien += child_liczba_wystapien;
						}
						printf("Liczba wystapien wzorca: %d", liczbaWystapien);
						pvm_exit();
						return 0;
					};
				\end{lstlisting}
