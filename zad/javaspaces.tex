% !TeX spellcheck = pl_PL
\newpage
% --- Opcje listingu kodu Javy
\lstset{
	language=Java,
	frame=single,
	autogobble=true,
	commentstyle=\ttfamily\itshape\color{gray},
	keywordstyle=\color{blue},
	frameround=ffff,
	rulecolor=\color{black},
	tabsize=4,
	breaklines=true,
	extendedchars
}

% --- Polskie znaki w listingu kodu
\lstset{
	literate=%
	{ą}{{\c{a}}}1
	{ć}{{\'c}}1
	{ę}{{\c{e}}}1
	{ł}{{\l{}}}1
	{ń}{{\'n}}1
	{ó}{{\'o}}1
	{ś}{{\'s}}1
	{ź}{{\'z}}1
	{ż}{{\.z}}1
	{Ą}{{\c{A}}}1
	{Ć}{{\'C}}1
	{Ę}{{\c{E}}}1
	{Ł}{{\L{}}}1
	{Ń}{{\'N}}1
	{Ó}{{\'O}}1
	{Ś}{{\'S}}1
	{Ź}{{\'Z}}1
	{Ż}{{\.Z}}1
}

\section{Java Spaces}
	\subsection{Wstęp z laborek}
		\subsubsection{Treść}
			Napisać program zawierający jednego Nadzorcę oraz wielu Pracowników. Nadzorca przekazuje do JavaSpace 2 równe tablice zawierające obiekty typu Integer, a następnie otrzymuje wynikową tablicę zawierającą sumy odpowiadających sobie komórek. Operację dodawania mają realizować Pracownicy.
		\subsubsection{Rozwiązanie}
			Zadanie obliczania sumy tabel dzielimy na dwie części: \textit{Task} oraz \textit{Result}. \textit{Taski} są generowane przez \textit{Nadzorcę} i przekazywane \textit{Pracownikom}, ci zaś wykonują zadanie i tworzą obiekty klasy \textit{Result}, a następnie przekazuję je \textit{Nadzorcy}. \textit{Nadzorca} je odbiera, kompletuje i ew. coś z nimi robi.\\\\
			\textit{Nadzorca} przydziela tyle zadań, ile potrzebuje, z kolei \textit{Pracownicy} działają w nieskończoność. Aby zakończyć ich pracę, \textit{Nadzorca} musi wysłać zadania z tzw. zatrutą pigułką (ang. \emph{Poisoned Pill}), czyli obiekt zadania z nietypowym parametrem, który sygnalizuje zakończenie pracy. Może to być np. \textit{Boolean} o wartości \textit{false}, \textit{Integer} o wartości -1, itp.
			Składowymi klas implementujących interfejs Entry nie mogą być typu prostego (int, double itp.), muszą być opakowane (Integer, Double itp.). Najbezpieczniej dawać je wszędzie.\\
			\begin{lstlisting}
				/**
				* @author Son Mati
				* @waifu Itsuka Kotori
				*/
				public class Task implements Entry {
					public Integer cellID;	// ID komórki tabeli
					public Integer valueA;	// wartość z tabeli A
					public Integer valueB;	// wartość z tabeli B
					public Boolean isPill;	// czy zadanie jest zatrutą pigułką

					// Domyślny konstruktor, musi się znajdować
					public Task() {
						this.cellID = this.valueA = this.valueB = null;
						this.isPill = false;
					}
					
					public Task(Integer entryID, Integer valueA, Integer valueB, Boolean isPill) {
						this.cellID = entryID;
						this.valueA = valueA;
						this.valueB = valueB;
						this.isPill = isPill;
					}
				}
			\end{lstlisting}
			\newpage
			\begin{lstlisting}
				/**
				* @author Son Mati
				* @waifu Itsuka Kotori
				*/
				public class Result implements Entry {
					public Integer cellID, value;
					public Result() {
						this.cellID = this.value = null;
					}
					public Result(final Integer EntryID, final Integer Value) {
						this.cellID = EntryID;
						this.value = Value;
					}
				}
			\end{lstlisting}
			\begin{lstlisting}
				public class Client {
					protected Integer defaultLease = 100000;
					protected JavaSpace space;
					protected Lookup lookup;
					public Client() {
						lookup = new Lookup(JavaSpace.class);
					}
				}
			\end{lstlisting}
			\begin{lstlisting}
				/**
				* @author Son Mati
				* @waifu Itsuka Kotori
				*/
				public class Worker extends Client {
					public Worker() {
					}
					public void startWorking() {
						while(true) {
							try {
								this.space = (JavaSpace)lookup.getService();
								Task task = new Task();
								task = (Task) space.take(task, null, defaultLease);
								if (task.isPill == true)
								{
									space.write(task, null, defaultLease);
									System.out.println("Koniec pracy workera.");
									return;
								}
								Integer res = task.valueA + task.valueB;
								Result result = new Result(task.cellID, res);
								space.write(result, null, defaultLease);
							}
							catch (Exception ex) {}
						}
					}
					public static void main(String[] args) {
						Worker w = new Worker();	// utworzenie obiektu
						w.startWorking();			// realizacja zadan
					}
				}
			\end{lstlisting}
			\newpage
			\begin{lstlisting}
				/**
				* @author Son Mati
				* @waifu Itsuka Kotori
				*/
				public class Supervisor extends Client {
					static final Integer INT_NUMBER = 125;
					public Integer[] TableA = new Integer[INT_NUMBER];
					public Integer[] TableB = new Integer[INT_NUMBER];
					public Integer[] TableC = new Integer[INT_NUMBER];
					// konstruktor
					public Supervisor() {
					}
					// wygenerowanie zawartości tablic
					public void generateData() {
						Random rand = new Random();
						for (int i = 0; i < INT_NUMBER; ++i) {
							TableA[i] = rand.nextInt(INT_NUMBER);
							TableB[i] = rand.nextInt(INT_NUMBER);
							TableC[i] = 0;
						}
					}
					// rozpoczecie pracy
					public void startProducing() {
						try {
							this.space = (JavaSpace)lookup.getService();
							// utworzenie zadania
							for (Integer i = 0; i < INT_NUMBER; ++i) {
								Task task = new Task(i, this.TableA[i], this.TableB[i], false);
								space.write(task, null, defaultLease);
							}
							// pobranie wyniku zadania
							System.out.println("Tablica C:");
							for(Integer i = 0 ; i < INT_NUMBER; ++i) {
								Result result = new Result();
								result = (Result) space.take(result, null, defaultLease);
								TableC[result.cellID] = result.value;
							}
							// utworzenie zatrutej pigulki na sam koniec
							Task poisonPill = new Task(null, null, null, true);
							space.write(poisonPill, null, defaultLease);
						}
						catch (Exception ex) {
						}
					}
				
					public static void main(String[] args) {
						// utworzenie obiektu
						Supervisor sv = new Supervisor();
						// utworzenie zadan
						sv.generateData();
						sv.startProducing();
					}
				}
			\end{lstlisting}

	\subsection{Zadanie 1}
		\subsubsection{Treść}
			Napisać program odbierający z przestrzeni JavaSpace kolejno 100 obiektów klasy Zadanie posiadające w atrybucie typ (typu całkowitego) wartość 15 i dla każdego obiektu Zadanie wygenerować i umieścić w przestrzeni JavaSpace obiekt klasy Silnia posiadający jako atrybut... (dalej nie pamiętam dobrze) wartość będącą silnią wartości uzyskanej z liczba(typu całkowitego) z klasy Zadanie.
	
	\newpage
	\subsection{2010, I termin, Adam Duszeńko}
		\subsubsection{Treść}
			Napisać kod programu głównego zarządzającego równoległym wykonywaniem zadania w maszynie JavaSpace polegającym na wyznaczeniu zbioru klatek video zawierających ruch. Wykrywanie ruchu ma odbywać się w procesorach wykonawczych na zasadzie porównania różnicowego, czyli wymaga poddania analizie dwóch kolejnych klatek. W tym celu program główny posługując się \textit{byte[] GetImage()} (przyjąć, że jest zdefiniowana i zaimplementowana) ma pobierać kolejne klatki obrazu i umieszczać je w przestrzeni JavaSpace, wraz z jej kolejnym numerem (numerowania ma odbywać się na poziomie programu głównego). Program główny kończy wysyłania zadań gdy funkcja \textit{GetImage} zwróci wartość \textit{NULL}. Jako wynik swojego działania programy wykonawcze zwracają obiekt odpowiedzi zawierający numer pierwszego obrazu z analizowanej pary oraz wartość logiczną czy para była identyczna czy też zawierała wykryty ruch. Na zakończenie działania program główny po zebraniu wszystkich odpowiedzi powinien wypisać numery obrazów dla których wykryto ruch oraz zakończyć procesy wykonawcze rozsyłając "zatrutą pigułkę". Zaproponować strukturę obiektu zadania i odpowiedzi.
		\subsubsection{Propozycja rozwiązania 1}
			Nie jest do końca prawidłowa, ponieważ kod nie jest spójny i nie wiadomo czy analizuje pary klatek.
			\begin{lstlisting}
				public class Image implements Entry {
					//należy pamiętać o tym aby każde pole było publiczne!
					public byte[] frame;
					public Integer id;
					//wymagane konstruktory
					public Image() {}
					public Image(Integer id, byte[] frame) {
						this.id = new Integer(id);
						this.frame = frame;
					}
				}
			\end{lstlisting}
			\begin{lstlisting}
				//Dane przesyłane jako odpowiedź
				public class Result implements Entry {
					public Integer id;
					public Boolean move;
					public Result() {}
					public Result(Integer id, Boolean move) {
						this.id = new Integer(id);
						this.move = new Boolean(move);
					}
				}
			\end{lstlisting}
			\newpage
			\begin{lstlisting}
				public class Program {
					public int defaultLease = 100000;
					public int id = 1;
					
					public void producer() {
						byte [] img1, img2;
						img1 = getImage();
						try {
							Lookup lookup = new Lookup(JavaSpace.class);
							JavaSpace space = (JavaSpace) lookup.getService();
							img2 = getImage();
							while(true) {
								img = getImage();	// dostarczone w zadaniu
								if (img == null || img2 == null) break;	// null = koniec
								Package data = new Data(id, img1, id + 1, img2);
								space.write(data, null, defaultLease);	// paczka do space
								img1 = img2;
								id++;
							}
						// bo breaku przełączamy się w tryb odbierania
						for (int i = 1; i < id; i++) {
							Result result = (Result) space.takeIfExsists(new Result(), null, defaultLease);
							if (result.move)
								System.out.println("Ruch obrazków: " + result.id1 + " " + result.id2);
						}
						space.write(new Image(), null, defaultLease);
						} catch (Exception e) {}
					}
					
					public void consumer() {
						try {
							Lookup lookup = new Lookup(JavaSpace.class);
							JavaSpace space = (JavaSpace) lookup.getService();
							int i = 0;
							while(true) {
								Image img1 = new Image();	img1.id = i++;
								Image img2 = new Image(); 	img2.id = i;
								img1 = (Image) space.take(img1, null, defaultLese);
								img2 = (Image) space.read(img2, null, defaultLese);
								//czy wysłano "zatrutą pigułkę"
								if (img2.frame == null && img2.id == null) break;
								// czy wykonano ruch na obrazkach
								if (img1.frame.equals(img2.frame)) {
									// tego chyba nie trzeba nawet wysyłać w tym zadaniu
									result = new Result(img2.id, false);
								} else {
									result = new Result(img2.id, true);
								}
								// wysyłanie wyniku do space
								space.write(result, null, defaultLease);
							}
						} catch (Exception e) {}
					}
				}
			\end{lstlisting}
	\newpage		
	\subsection{2011, I termin, Adam Duszeńko}
		\subsubsection{Treść}
			Napisać program umieszczający w przestrzeni JavaSpace \textbf{10} obiektów zadań zawierających \textbf{dwa} pola typu całkowitego oraz \textbf{dwa} pola typu łańcuch znakowy (zawartość nieistotna, różna od NULL), podać deklarację klasy zadań. Następnie odebrać z przestrzeni kolejno \textbf{10} obiektów klasy \textit{Odpowiedź} o atrybutach \textit{id} typu \textit{Integer} oraz \textit{wynik} typu \textit{Integer} posiadające w atrybucie id wartość \textbf{15}, a następnie wszystkie z atrybutem \textit{id} = \textbf{110}. Przyjąć, że klasa \textit{Odpowiedź} jest już zdefiniowana zgodnie z powyższym opisem.
	
	\subsection{2012, I termin, Adam Duszeńko}
		\subsubsection{Treść}
			Napisać program umieszczający w przestrzeni JavaSpace \textbf{1000} obiektów zadań zawierających \textbf{trzy} pola typu całkowitego oraz \textbf{dwa} pola typu łańcuch znakowy (zawartość nieistotna, różna od NULL), podać deklarację klasy zadań. Następnie odebrać z przestrzeni kolejno \textbf{1000} obiektów klasy \textit{Odpowiedź} o atrybutach \textit{id} typu \textit{Integer} oraz \textit{wynik} typu \textit{Integer} posiadające w atrybucie id wartość \textbf{35}, a następnie wszystkie z atrybutem \textit{id} = \textbf{10}. Przyjąć, że klasa \textit{Odpowiedź} jest już zdefiniowana zgodnie z powyższym opisem.
	
	\newpage
	\subsection{2013, I termin}
		\subsubsection{Treść}
			Napisać program umieszczający w przestrzeni JavaSpace \textbf{200} obiektów zadań zawierających \textbf{dwa} pola typu całkowitego oraz \textbf{dwa} pola typu łańcuch znakowy (zawartość nieistotna, różna od NULL), podać deklarację klasy zadań. Następnie odebrać z przestrzeni kolejno \textbf{100} obiektów klasy \textit{Odpowiedź} o atrybutach \textit{id} typu \textit{Integer} oraz \textit{wynik} typu \textit{Integer} posiadające w atrybucie id wartość \textbf{35}, a następnie wszystkie z atrybutem \textit{id} = \textbf{10}. Przyjąć, że klasa \textit{Odpowiedź} jest już zdefiniowana zgodnie z powyższym opisem.
	
		\subsubsection{Propozycja rozwiązania 1}
			\begin{lstlisting}
				public class MessageSend implements Entry {
					public String s1, s2;
					public Integer i1, i2;
					public MessageSend() {
						s1 = s2 = i1 = i2 = null;
					}
					public MessageSend(String s1, String s2, Integer i1, Integer i2) {
						this(s1, s2, i1, i2)
					}
				}
				
				public class Producent {
					Lookup lookup;
					public Producent() {
						lookup = new Lookup(JavaSpace.class);
					}
					public void produce() {
						try {
							JavaSpace space = (JavaSpace) finder.getService();
							for(int i = 0; i < 200; ++i) {
								space.write(new MessageSend("a", "a", i, i), null, 100000);
							}
							Odpowiedź data;
							for(int i = 0; i < 100; ++i) {
								data = new Odpowiedź();
								data.id = 35;
								data.wartość = null;
								space.take(data, null, 100000);
							}
							while(true) {
								data = new Odpowiedź();
								data.id = 10;
								data.wartość = null;
								data = (Odpowiedź) space.takeIfExists(data, null, 100000);
								if (data == null) break;
							}
						catch(Exception e) { }
						}
					}
					public static void main(String[] args) {
						Producent tmp = new Producent();
						tmp.Producer();
					}
				}
			\end{lstlisting}
		\subsubsection{Propozycja rozwiązania 2}
			\begin{lstlisting}
				package pl.ak.javaspaces;
				import net.jini.core.entry.Entry;
				import net.jini.core.transaction.TransactionException;
				import net.jini.space.JavaSpace;
				
				public class JavaSpaceObject implements Entry {
					public String s1, s2;
					public Integer i1, i2;
					public JavaSpaceObject() {
						this(null, null, null, null);
					}
					public JavaSpaceObject(String s1, String s2, Integer i1, Integer i2) {
						this(s1, s2, i1, i2)
					}
					public String toString() {
						return data;
					} 
				}
				
				public class JavaSpaces {
					public static void main(String[] args) {
						try {
							Lookup finder = new Lookup(JavaSpace.class);
							JavaSpace space = (JavaSpace) finder.getService();
							for(int i = 0; i < 200; ++i) {
								space.write(new JavaSpaceObject("a","a",i,i), null, 100000);
							}
							Odpowiedź data;
							for (int i = 0; i < 100; ++i) {
								data = new Odpowiedź();
								data.id = 35;
								data.wartość = null;
								space.take(data, null, 100000);
							}
							while(true) {
								data = new Odpowiedź();
								data.id = 10;
								data.wartość = null;
								data = (Odpowiedź) space.takeIfExists(data, null, 100000);
								if (data == null)
									break;
							}
							catch(Exception e) {
								System.out.println(e.getMessage());
							}
						}
					}
				}
			\end{lstlisting}
	\newpage
	\subsection{2014, I termin, Adam Duszeńko}
		\subsubsection{Treść}
			Napisać kod programu głównego wykonawczego do przetwarzania z wykorzystaniem maszyny JavaSpace przetwarzającego obiekty zadań zawierające dwie wartości całkowite, oraz numer obiektu i flagę logiczną początkowo zawierającą wartość \textit{FALSE}. W momencie pobrania obiektu zadania program wykonawczy ma podmienić w przestrzeni JavaSpace pobrany obiekt na ten sam, ale z flagą ustawioną na wartość \textit{TRUE}. Przetwarzanie obiektu realizowane jest w funkcji \textit{int check(int, int)} do której należy przekazać wartości z obiektu zadania. PO skończeniu przetwarzania zadania, przed zwróceniem wyniku, należy usunąć z przestrzeni JavaSpace obiekt przetwarzanego zadania. Wynik funkcji \textit{check} należy umieścić w obiekcie wynikowym którego strukturę proszę zaproponować. Obsłużyć koniec działania programu przez skonsumowanie "zatrutej pigułki".
		\subsubsection{Propozycja rozwiązania 1}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	