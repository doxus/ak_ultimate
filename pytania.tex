% !TeX spellcheck = pl_PL

%===============================================================================
% *** PYTANIA I ODPOWIEDZI *****************************************************
%===============================================================================
\part{Pytania zamknięte}
\begin{enumerate}
\question{%
	question={Moc obliczeniowa komputerów wektorowych}%
}{%
	isTrue1={Nie},%
	answer1={Zależy od liczby stopni potoku.},%
	explain1={Moc obliczeniowa nie jest zależna od liczby stopni potoku. Ta jedynie wpływa na ilosć rozkazów jakie mogą być wykonane w chwili czasu w jednostce potokowej.},%
	isTrue2={Tak},%
	answer2={Jest odwrotnie proporcjonalna do długości taktu zegarowego},%
	explain2={Tak, obliczamy ją wzorem $Przep=lim_{n\to\infty}\frac{n}{t_{start}+(n-1)\times\tau}=\frac{1}{\tau}$},%
	isTrue3={Nie},%
	answer3={Jest wprost proporcjonalna do długości taktu zegarowego},%
	explain3={Nie, patrz wyżej.},%
	isTrue4={Nie},%
	answer4={Zależy odwrotnie proporcjonalnie od liczby jednostek potokowych połączonych łańcuchowo.},%
	explain4={Nie, idea operacji wektorowej na komputerze wektorowym zakłada jedną jednostkę potokową. Ich zwiększenie nie powinno wpłynąć bezpośrednio na moc.},%
	isTrue5={Tak},%
	answer5={Zmierza asymptotycznie do wartości maksymalnej wraz ze wzrostem długości wektora}, %
	explain5={Tak, istnieje pewna wartość maksymalna do której moc dąży logarytmicznie wraz ze wzrostem długości wektora.}, %
	isTrue6={Nie}, %
	answer6={Nie zależy od długości wektora}, %
	explain6={Bzdura, patrz wyżej.}, %
	isTrue7={Nie}, %
	answer7={Zależy liniowo od długości wektora}, %
	explain7={Bzdura, patrz wyżej.}, %
}


\question{%
	question={Czy poniższa lista jest rosnąco uporządkowana według skalowalności:}%
}{%
	isTrue1={Nie},%
	answer1={Systemy ściśle połączone, systemy ze wspólną pamięcią, systemy SMP},%
	explain1={},%
	isTrue2={Tak},%
	answer2={Systemy ze wspólna magistralą, systemy wielomagistralowe, systemy z przełącznicą krzyżową},%
	explain2={},%
	isTrue3={Nie},%
	answer3={Systemy SMP, systemy z pamięcią wieloportową, systemy z przełącznicą krzyżową},%
	explain3={},%
	isTrue4={Nie},%
	answer4={NUMA, MPP, SMP},%
	explain4={},%
	isTrue5={Tak},%
	answer5={Systemy z pamięcią wspólną, systemy o niejednorodnym dostępie do pamięci, z pamięcią rozproszoną}, %
	explain5={}, %
	isTrue6={Nie}, %
	answer6={Systemy SMP, NUMA, klastry, UMA}, %
	explain6={}, %
	isTrue7={Tak}, %
	answer7={Systemy symetryczne, o niejednorodnym dostępie do pamięci, systemy z przesyłem komunikatów}, %
	explain7={}, %
}


\question{%
	question={Komputery macierzowe}%
}{%
	isTrue1={Tak},%
	answer1={Mają w liście rozkazów m.in. rozkazy operujące na wektorach danych},%
	explain1={Tak, te komputery są rozwinięciem komputerów wektorowych i muszą mieć rozkazy wektorowe. Komputery macierzowe posiadają po \emph{n} jednostek przetwarzających, które potrafią razem obliczyć \emph{n} składowych wektora.},%
	isTrue2={Nie},%
	answer2={Mają macierzowe potokowe układy arytmetyczne},%
	explain2={Nie, posiadają natomiast jednostki przetwarzające. Z kolei potokową jednostkę arytmetyczną posiadają komputery wektorowe.},%
	isTrue3={Nie},%
	answer3={Mają w typowych rozwiązaniach zestaw pełnych procesów połączonych siecią połączeń},%
	explain3={Nie, w typowym rozwiązaniu jest jeden pełny procesor z wieloma jednostkami potokowymi, które są połączone siecią łączącą (statyczną lub dynamiczną). Sieć połączeń pełnych procków posiadają superkomputery z top500 (Nie jestem pewien tej odpowiedzi).},%
	isTrue4={Tak},%
	answer4={Wykonują synchroniczną operację wektorową w sieci elementów przetwarzających},%
	explain4={Tak właśnie działają.},%
}


\question{%
	question={Przetwarzanie potokowe}%
}{%
	isTrue1={Nie},%
	answer1={Nie jest realizowane dla operacji zmiennoprzecinkowych},%
	explain1={Nie ma takiego ograniczenia. Przetwarzanie potokowe dotyczy optymalizacji czasu wykonywania rozkazów - podziału realizacji rozkazu na fazy. Owszem, dla argumentów zmiennoprzecinkowych mogą wystąpić problemy związane z czasem obliczeń (uniemożliwienie wykonania rozkazu w jednym takcie), co może zablokować napełnianie potoku, jednak nie uniemożliwia to zastosowania potoku.},%
	isTrue2={Nie},%
	answer2={Nie jest realizowane w procesorach CISC},%
	explain2={Przetwarzanie potokowe znalazło zastosowanie głównie w architekturze RISC, jednak CISC też z niej korzysta. Przykłady: VAX 11/780 (CISC), Ultra SPARC III (RISC)},%
	isTrue3={Tak},%
	answer3={Daje przyspieszenie nie większe od liczby segmentów (stopni) jednostki potokowej},%
	explain3={Tak, przyspieszenie jest stosunkiem czasu wykonywania \emph{n} rozkazów dla procesora niepotokowego oraz czasu dla procesora potokowego. W idealnym przypadku, gdy każdy stopień dzieli okres rozkazu po równo, a liczba rozkazów dąży do nieskończoności, stosunek ten jest równy P - ilości stopni.},%
	isTrue4={Nie},%
	answer4={W przypadku wystąpienia zależności między danymi wywołuje błąd i przerwanie wewnętrzne.},%
	explain4={Hm, dobre pytanie. Tak, zależności danych mogą wystąpić (zjawisko hazardu) i rozdupić program, ale po to właśnie istnieją mechanizmy by temu zapobiegać. Każda szanująca się architektura to potrafi: albo sprzętowo, albo na etapie kompilacji, która modyfikuje i optymalizuje program. A jeżeli po modyfikacji pewien rozkaz nie wykona się w jednym takcie, napełnianie potoku jest przerywane (ale błędu chyba nie wywala), patrz wyżej.},%
	isTrue5={Nie},%
	answer5={Jest realizowane tylko dla operacji zmiennoprzecinkowych}, %
	explain5={Pfff, no chyba nie XD Jest realizowane dla każdego rodzaju rozkazu.} %
}

% --- PYTANIE 5
\question{%
	question={W procesorach superskalarnych}%
}{%
	isTrue1={Tak},%
	answer1={Liczba rozkazów, które procesor może wykonać w 1 takcie zależy od liczby jednostek potokowych w procesorze},%
	explain1={Procesory superskalarne posiadają wiele jednostek potokowych, które są konieczne by móc wykonywać wiele rozkazów w jednym takcie. Od ich liczby zależy owa liczba rozkazów.},%
	isTrue2={Nie},%
	answer2={Liczba rozkazów, które procesor może wykonać w jednym takcie, zależy od liczby stopni potoku.},%
	explain2={Nie, liczba stopni potoku mówi, na ile części dzieli się dany rozkaz w tej jednostce potokowej. One umożliwiają wykonanie wielu rozkazów w jednej jednostce czasu, jednak nie przekłada się to bezpośrednio na liczbę rozkazów, ze względu na zawikłania czasowe, oraz nie jest to idea procesora superskalarnego.},%
	isTrue3={Nie},%
	answer3={Liczba rozkazów pobieranych z pamięci, w każdym takcie musi przekraczać liczbę jednostek potokowych},%
	explain3={Liczba pobranych rozkazów powinna być co najmniej równa ilości jednostek potokowych.},%
	isTrue4={Tak},%
	answer4={Liczba rozkazów, które procesor może wykonać w taktach zależy od liczby jednostek potokowych w procesorze},%
	explain4={Tak, patrz pierwsza odpowiedź.},%
}


\question{%
	question={Systemy SMP (odpowiedzi ?? do sprawdzenia)}%
}{%
isTrue1={Nie},%
answer1={Wykorzystują protokół MESI do sterowania dostępem do wspólnej magistrali},%
explain1={},%
isTrue2={Nie},%
answer2={Posiadają skalowalne procesory},%
explain2={},%
isTrue3={Nie},%
answer3={Posiadają pamięć fizycznie rozproszoną, ale logicznie wspólną},%
explain3={},%
}


\question{%
	question={Komputery wektorowe}%
}{%
isTrue1={Nie},%
answer1={Posiadają jednostki potokowe o budowie wektorowej},%
explain1={Nie, posiadają potokowe jednostki arytmetyczne, które nie są wektorowe.},%
isTrue2={Tak},%
answer2={Posiadają w liście rozkazów m.in. rozkazy operujące na wektorach danych},%
explain2={Jak najbardziej, nie mogłyby się bez tego obejść.},%
isTrue3={Tak},%
answer3={Wykorzystują od kilku do kilkunastu potokowych jednostek arytmetycznych},%
explain3={Tak, tych jednostek może być wiele, można to zauważyć na przykładzie komputera Cray-1 (wykład 7-8, slajd 31)},%
isTrue4={Nie},%
answer4={Posiadają listę rozkazów operujących wyłącznie na wektorach},%
explain4={Zdecydowanie nie. Owszem, te komputery posiadają rejestry wektorowe i wektorowe jednostki zmiennoprzecinkowe, ale nie jest to wszystko. Mają również normalne rejestry, adresację, jednostki skalarne i możliwość wykonywania na nich operacji.},%
}


\question{%
	question={Procesory wektorowe}%
}{%
isTrue1={Tak},%
answer1={Mogą być stosowane w systemach wieloprocesorowych},%
explain1={Domyślnie procesory wektorowe mogą pracować pojedynczo, ale mogą być częścią takiego systemu. Poza tym nie znalazłem nic, co by temu przeczyło. Jest też np. CUDA - architektura wielordzeniowych procesorów graficznych. Sama architektura SIMD działa na wielu procesorach.},%
isTrue2={Nie},%
answer2={Mają listę rozkazów operującą jedynie na wektorach},%
explain2={Nie, posiadają też m.in. potokowe jednostki arytmetyczne oraz jednostki skalarne, do operowania na zwykłych liczbach.},%
isTrue3={Tak},%
answer3={Mają moc kilka razy większą od procesorów skalarnych},%
explain3={Tak, przyspieszenie jest ilorazem czasu wykonywania na procesorze niewektorowym do czasu wykonywania na procesorze wektorowym. Np. dla rozkazu dodawania \emph{n} wektorów przyspieszenie wyliczane jest wg wzoru $ a=\frac{15\tau n}{t_{start}+(n-1)\tau} $, gdzie przy \emph{n} dążącym do nieskończoności \emph{a} jest równe 15.},%
}


\question{%
	question={Systemy MPP są zbudowane z węzłów którymi mogą być}%
}{%
isTrue1={Tak},%
answer1={Systemy SMP},%
explain1={},%
isTrue2={Nie},%
answer2={Klastry},%
explain2={},%
isTrue3={Nie},%
answer3={Konstelacje},%
explain3={},%
isTrue4={Tak},%
answer4={Systemy NUMA},%
explain4={},%
isTrue5={Tak},%
answer5={Procesory}, %
explain5={}, %
}


% --- PYTANIE 10
\question{%
	question={W architekturze NUMA}%
}{%
isTrue1={Tak},%
answer1={Dane są wymieniane między węzłami w postaci linii pamięci podręcznej (PaP)},%
explain1={},%
isTrue2={Nie},%
answer2={Spójność PaP węzłów jest utrzymywana za pomocą protokołu MESI},%
explain2={},%
isTrue3={Nie},%
answer3={Czas dostępu do pamięci lokalnej w węźle jest podobny do czasu dostępu do pamięci nielokalnej},%
explain3={},%
isTrue4={Tak},%
answer4={Czas zapisu danych do pamięci nielokalnej może być znacznie dłuższy od czasu odczytu z tej pamięci},%
explain4={},%
isTrue5={Tak},%
answer5={Każdy procesor ma dostęp do pamięci operacyjnej każdego węzła}, %
explain5={}, %
isTrue6={Nie}, %
answer6={Procesy komunikują się poprzez przesył komunikatów}, %
explain6={}, %
isTrue7={Tak}, %
answer7={Pamięć operacyjna jest rozproszona fizycznie pomiędzy węzłami, ale wspólna logicznie}, %
explain7={}, %
}


\question{%
	question={Mechanizmy potokowe stosowane są w celu}%
}{%
isTrue1={Nie},%
answer1={Uszeregowania ciągu wykonywanych rozkazów},%
explain1={Nie, zupełnie nie o to chodzi. Ciąg może zostać uszeregowany przez kompilator w celu optymalizacji. Jednak celem tego mechanizmu jest zrównoleglenie wykonywania rozkazów $ \rightarrow $ zmiana kolejności ich realizacji nie jest założeniem.},%
isTrue2={Tak},%
answer2={Uzyskania równoległej realizacji rozkazów},%
explain2={No tyć. Potoki umożliwiają realizację wielu rozkazów jednocześnie dzieląc jednostkę centralną na wg stopni, jak np. pobranie rozkazu i wykonania rozkazu. Dzięki temu dwa rozkazy mogą wykonywać się jednocześnie, oba w innych fazach (jednostkach czasu).},%
isTrue3={Tak},%
answer3={Przyspieszenia realizacji rozkazów},%
explain3={Tak, to główny cel. Umożliwienie wykonania rozkazów umożliwia przyspieszenie, które oblicza się jako stosunek czasu wykonywania rozkazów w procesorze niepotokowym do czasu realizacji w procesorze potokowym. W idealnym przypadku jest ono równe \emph{P} - ilości podziałów / stopni / faz / zwał jak zwał.},%
}


\question{%
	question={Protokół MESI}%
}{%
isTrue1={Nie},%
answer1={Jest wykorzystywany do sterowania dostępem do magistrali w systemie SMP},%
explain1={},%
isTrue2={Tak},%
answer2={Zapewnia spójność pamięci cache w systemie SMP},%
explain2={},%
isTrue3={Nie},%
answer3={Służy do wymiany komunikatów w systemie MPP},%
explain3={},%
isTrue4={Nie},%
answer4={Chroni przed hazardem w proc superskalarnych},%
explain4={},%
}


\question{%
	question={Mechanizm skoków opóźnionych}%
}{%
isTrue1={Tak},%
answer1={Polega na opóźnianiu wykonywania skoku do czasu wykonania rozkazu następnego za skokiem},%
explain1={Tak, cały ten mechanizm sprowadza się do opóźnienia efektu skoku o jeden rozkaz. Zapewnia to, że rozkaz następny po skoku zawsze będzie wykonywany w całości.},%
isTrue2={Nie},%
answer2={Wymaga wstrzymania potoku na jeden takt.},%
explain2={Nie, mechanizm potoków nie musi być wstrzymywany. Mechanizm ten zmienia postać programu w trakcie kompilacji, ale na samą realizację potoku nie ma wpływu (afaik, not sure).},%
isTrue3={Nie},%
answer3={Powoduje błąd na końcu pętli},%
explain3={Pfff, jak programista ssie pałę to tak, jednak w założeniu tak się nie dzieje.},%
isTrue4={Tak},%
answer4={Wymaga umieszczenia rozkazu NOP za rozkazem skoku lub reorganizacje programu},%
explain4={Tak, mechanizm sprowadza się do tego, i tylko do tego, patrz pierwsza odpowiedź.},%
}


\question{%
	question={Charakterystyczne cechy architektury MPP}%
}{%
isTrue1={Nie},%
answer1={Spójność pamięci podręcznej wszystkich węzłów},%
explain1={},%
isTrue2={Tak},%
answer2={Fizycznie rozproszona PaO},%
explain2={},%
isTrue3={Nie},%
answer3={Fizycznie rozproszona PaO, ale logicznie wspólna},%
explain3={},%
isTrue4={Tak},%
answer4={Przesył komunikatów między procesorami},%
explain4={},%
isTrue5={Nie},%
answer5={Niska skalowalność}, %
explain5={}, %
isTrue6={Nie}, %
answer6={Jednorodny dostęp do pamięci wszystkich węzłów}, %
explain6={}, %
}


% --- PTYTANIE 15
\question{%
	question={Jak można ominąć hazard danych}%
}{%
isTrue1={Nie},%
answer1={Poprzez rozgałęzienia},%
explain1={Nie, rozgałęzienie to po prostu instrukcje typu IF, które tworzą takie rozgałęzienia. Mechanizm przewidywania rozgałęzień jest stosowany do usuwania hazardu sterowania związanego ze skokami i rozgałęzieniami.},%
isTrue2={Nie},%
answer2={Poprzez uproszczenie adresowania - adresowanie bezpośrednie.},%
explain2={Bullshit. Nie wiem w czym miało by pomóc uproszczenia adresowania, poza pójściem w stronę RISCu, ale na hazard to nie pomoże. Tym można tylko skrócić czas odwołania się do danych.},%
isTrue3={Tak},%
answer3={Przez zamianę rozkazów},%
explain3={Tak, i na tym polega mechanizm skoków opóźnionych, które mogą program zmodyfikować (dodać rozkaz NOP) albo zoptymalizować, właśnie zamieniają rozkazy kolejnością.},%
}


\question{%
	question={Cechy architektury CISC}%
}{%
isTrue1={Nie},%
answer1={Czy może być wykonana w VLIW},%
explain1={Nie, architektura VLIW dotyczy mikroprocesorów i miała na celu jak największe zmniejszenie jednostki centralnej i jej rozkazów (RISC).},%
isTrue2={Tak},%
answer2={Czy występuje model wymiany danych typu pamięć - pamięć},%
explain2={Tak, posiada również niewielką ilość rejestrów.},%
isTrue3={Nie},%
answer3={Jest mała liczba rozkazów},%
explain3={Nie, w tej architekturze jest PEŁNA (complex) lista rozkazów. Niektóre z zaawansowanych pleceń nawet nie były wykorzystywane, i bum! tak powstał RISC.},%
}


\question{%
	question={Cechy architektury RISC}%
}{%
isTrue1={Tak},%
answer1={Czy występuje model wymiany danych typu rej-rej},%
explain1={Tak, a komunikacja z pamięcią operacyjną odbywa się wyłącznie za pomocą rozkazów LOAD i STORE.},%
isTrue2={Tak},%
answer2={Jest mała liczba trybów adresowania},%
explain2={Tak, raptem 4 w procesorze RISC I podczas gdy CISCi mogą mieć ich kilkanaście, w tym takie bardzo złożone.},%
isTrue3={Nie},%
answer3={Jest wykonywanych kilka rozkazów w jednym takcie},%
explain3={Fałsz. Prawdziwe wykonywanie wielu rozkazów w jednym takcie wymaga superskalarnosci - wielu jednostek potokowych. Cechą architektury RISC jest potokowość, ale pojedyncza.},%
isTrue4={Tak},%
answer4={Jest wykonywanych kilka rozkazów w jednym takcie (w danej chwili czasu)},%
explain4={Chodzi o przetwarzanie potokowe. Tu jest haczyk - pierwszy procesor RISC I (1980) stawiał sobie za cel wykonanie \emph{jednego rozkazu w jednym takcie} i dokładnie tak brzmiało jego założenie projektowe. Jednak jego fizyczna realizacja (1982) posiadała dwustopniowy potok. Również w wykładach jako cecha tej architektury jest napisane "Intensywne wykorzystanie przetwarzania potokowego", co odnosi się do faktu, że obecnie nie ma procesora typu RISC, który go nie ma. Wg mnie prawda.},%
isTrue5={Nie},%
answer5={Jest wykonywanych kilka instrukcji procesora w jednym rozkazie asemblerowym}, %
explain5={Nic mi na ten temat nie wiadomo. Brzmi jednak zbyt hardo i odlegle od tematu zmniejszania ilości rozkazów.}, %
isTrue6={Tak}, %
answer6={Układ sterowania w postaci logiki szytej}, %
explain6={Tak.}, %
}


\question{%
	question={Przepustowość (moc obliczeniowa) dużych komputerów jest podawana w:}%
}{%
isTrue1={Tak},%
answer1={GFLOPS},%
explain1={},%
isTrue2={Nie},%
answer2={Liczbie instrukcji wykonywanych na sekundę},%
explain2={},%
isTrue3={Tak},%
answer3={Liczbie operacji zmiennoprzecinkowych na sekundę},%
explain3={},%
isTrue4={Nie},%
answer4={Mb/sek},%
explain4={To jest do zapamiętania na prostu - takie są standardy},%
}


\question{%
	question={Podstawą klasyfikacji Flynna jest}%
}{%
isTrue1={Nie},%
answer1={Liczba jednostek przetwarzających i sterujących w systemach komputerowych},%
explain1={},%
isTrue2={Nie},%
answer2={Protokół dostępu do pamięci operacyjnej},%
explain2={},%
isTrue3={Nie},%
answer3={Liczba modułów pamięci operacyjnej w systemach komputerowych},%
explain3={},%
isTrue4={Tak},%
answer4={Liczba strumieni rozkazów i danych w systemach komputerowych},%
explain4={To po prostu należy zapamiętać. \textbf{Kryterium klasyfikacji Flynna jest \emph{liczba strumieni rozkazów} oraz \emph{liczba strumieni danych} w systemie komputerowym. NIC WIĘCEJ, NIC MNIEJ.\\Albo inaczej: \emph{$Liczba\_strumieni\times(rozkazow+danych)$}}},%
}


% --- PYTANIE 20
\question{%
	question={Rozkazy wektorowe mogą być realizowane przy wykorzystaniu}%
}{%
isTrue1={Tak},%
answer1={Macierzy elementów przetwarzających},%
explain1={Tak, komputery macierzowe operują na rozkazach wektorowych.},%
isTrue2={Nie},%
answer2={Zestawu procesorów superskalarnych},%
explain2={Procesory superskalarne w założeniu nie posiadają rozkazów wektorowych.},%
isTrue3={Tak},%
answer3={Technologii MMX},%
explain3={Tak, jest to pochodna technologia modelu SIMD, wykonuje operacje na krótkich wektorach (64-bit)},%
isTrue4={Nie},%
answer4={Sieci połączeń typu krata},%
explain4={Jest to sieć połączeń, która łączy jednostki przetwarzające w komputerze macierzowym. Raczej na wektorach na częsć komputera nie działa.},%
isTrue5={Tak},%
answer5={Potokowych jednostek arytmetycznych}, %
explain5={Tak, takie znajdują się w komputerach wektorowych.}, %
}


\question{%
	question={Architektura superskalarna}%
}{%
isTrue1={Nie},%
answer1={Dotyczy systemów SMP},%
explain1={Zdecydowanie nie tylko. Architektura superskalarna wymaga mechanizmu potokowego, czyli dotyczy głównie architektury RISC.},%
isTrue2={Nie},%
answer2={Wymaga zastosowania protokołu MESI},%
explain2={Nie, architektura superskalarna wymaga jedynie zastosowania co najmniej dwóch jednostek potokowych.},%
isTrue3={Tak},%
answer3={Umożliwia równoległe wykonywanie kilku rozkazów w jednym procesorze},%
explain3={Tak, i taki jest cel jej istnienia. Umożliwia to mechanizm potokowy.},%
isTrue4={Nie},%
answer4={Wywodzi się z architektury VLIW},%
explain4={Wręcz odwrotnie, to VLIW wykorzystuje architekturę superskalarną na której opiera swój podział rozkazów na paczki.},%
}


\question{%
	question={Klastry}%
}{%
isTrue1={Nie},%
answer1={Mają średnią skalowalność},%
explain1={},%
isTrue2={Nie},%
answer2={Wykorzystują model wspólnej pamięci},%
explain2={},%
isTrue3={Tak},%
answer3={W węzłach mogą wykorzystywać systemy SMP},%
explain3={},%
isTrue4={Tak},%
answer4={Do komunikacji między procesami wykorzystują przesył komunikatów},%
explain4={},%
isTrue5={Nie},%
answer5={Wykorzystują przełącznicę krzyżową jako sieć łączącą węzły}, %
explain5={}, %
isTrue6={Tak}, %
answer6={W każdym węźle posiadają pełną instalację systemu operacyjnego}, %
explain6={}, %
}


\question{%
	question={Pojęcie równoległości na poziomie rozkazów}%
}{%
isTrue1={Nie},%
answer1={Dotyczy architektury MIMD},%
explain1={Nie, ten rodzaj równoległości dotyczy mechanizmów potokowych (CISC i RISC), architektury superskalarnej oraz VLIW.},%
isTrue2={Tak},%
answer2={Odnosi się m.in. do przetwarzania potokowego},%
explain2={Tak, ideą mechanizmu potoków jest zrównoleglenie rozkazów i możliwość wykonywania wielu z nich w tej samej chwili czasu.},%
isTrue3={Nie},%
answer3={Dotyczy architektury MPP},%
explain3={Nie, patrz wyżej.},%
isTrue4={Tak},%
answer4={Dotyczy m.in. architektury superskalarnej},%
explain4={Tak, patrz wyżej.},%
}


\question{%
	question={Systemy wieloprocesorowe z pamięcią wspólną}%
}{%
isTrue1={Nie},%
answer1={Zapewniają jednorodny dostęp do pamięci},%
explain1={},%
isTrue2={Tak},%
answer2={Mogą wykorzystywać procesory CISC},%
explain2={},%
isTrue3={Tak},%
answer3={Są wykorzystywane w klastrach},%
explain3={},%
isTrue4={Nie},%
answer4={Wykorzystują przesył komunikatów między procesorami},%
explain4={},%
isTrue5={Tak},%
answer5={Wykorzystują katalog do utrzymania spójności pamięci podręcznych}, %
explain5={}, %
}


% --- PYTANIE 25
\question{%
	question={Hazard danych}%
}{%
isTrue1={Tak},%
answer1={Czasami może być usunięty przez zmianę kolejności wykonania rozkazów},%
explain1={Tak, służy do tego mechanizm skoków opóźnionych, który odbywa się na poziomie kompilacji programu.},%
isTrue2={Nie},%
answer2={Nie występuje w architekturze superskalarnej},%
explain2={Występuje wszędzie tam gdzie jest potokowe przetwarzania rozkazów.},%
isTrue3={Nie},%
answer3={Jest eliminowany przez zastosowanie specjalnego bitu w kodzie program},%
explain3={Nic mi o tym nie wiadomo. Pewne dodatkowe bity są wykorzystywane w mechanizmie przewidywania rozgałęzień, który służy do eliminacji hazardu, jednak on to odbywa się PRZED realizacją programu i sprowadza się do zmiany kolejnosci wykonywania rozkazów przez kompilator. Nic nie dodaje do treści programu.},%
isTrue4={Nie},%
answer4={Może wymagać wyczyszczenia potoku i rozpoczęcia nowej (...)},%
explain4={Nie wiem jak hazard danych może czegokolwiek wymagać skoro jest zjawiskiem ubocznym i je eliminujemy. Sprzętowa i programowa eliminacja hazardu jedynie może doprowadzić do \textbf{wstrzymania} napełniania potoku.},%
}


\question{%
	question={Przetwarzanie wielowątkowe}%
}{%
isTrue1={Tak},%
answer1={Zapewnia lepsze wykorzystanie potoków},%
explain1={Tak, ma na celu minimalizację strat cykli w trakcie realizacji wątku, jakie mogą powstać na wskutek:\\ - chybionych odwołań do pamięci podręcznej;\\- błędów w przewidywaniu rozgałęzień;\\- zależności między argumentami},%
isTrue2={Tak},%
answer2={Minimalizuje straty wynikające z chybionych odwołań do pamięci podręcznej},%
explain2={Tak, patrz wyżej.},%
isTrue3={Tak},%
answer3={Wymaga zwielokrotnienia zasobów procesora (rejestry, liczniki rozkazów, itp.)},%
explain3={Niestety tak, jest to warunek sprzętowej realizacji wielowątkowości.},%
isTrue4={Nie},%
answer4={Nie może być stosowane w przypadku hazardu danych},%
explain4={Nie, hazard danych wynika z zależności między argumentami, które są naturalnym ryzykiem przy stosowaniu mechanizmu potokowego. Nie powinny być blokowane z tego powodu, tym bardziej, że wielowątkowość ma dodatkowo chronić liczbę cykli przed zgubnym wpływem hazardu.}, %
}


\question{%
	question={Okna rejestrów}%
}{%
isTrue1={Nie},%
answer1={Chronią przez hazardem danych},%
explain1={Lolnope, od tego są mechanizmy skoków opóźnionych i przewidywania rozgałęzień. Okno rejestrów zapewnia ciągłe i optymalne wykonywanie procedur.},%
isTrue2={Tak},%
answer2={Minimalizują liczbę odwołań do pamięci operacyjnej przy operacjach wywołania procedur},%
explain2={Tak, dokładnie do tego one służą. Rejestr niski procedury A staje się rejestrem wysokim procedury B itd. Innymi słowy, procedura A wywołuje procedurę B, i tak dalej. I po coś w tym wszystkim są rejestry globalne.},%
isTrue3={Nie},%
answer3={Są charakterystyczne dla architektury CISC},%
explain3={Nie, zostały zaprojektowane specjalnie dla architektury RISC. Jako pierwszy posiadał je procesor RISC I.},%
isTrue4={Nie},%
answer4={Są zamykane po błędnym przewidywaniu wykonania skoków warunkowych.},%
explain4={W mechanizmie prognozowania rozgałęzień jest możliwość błędnego przewidywania. Jednak błędna prognoza powoduje tylko zmianę strategii (przewidywanie wykonania lub niewykonania), a nie zamykanie okna.},%
isTrue5={Tak},%
answer5={Są przesuwane przy operacjach wywołania procedur}, %
explain5={Tak, z każdą nową wywołaną procedurą okno rejestrów przesuwane jest w dół (ze 137 do 0)}, %
}


\question{%
	question={Tablica historii rozgałęzień}%
}{%
isTrue1={Tak},%
answer1={Zawiera m.in. adresy rozkazów rozgałęzień},%
explain1={Tak, tablica ta zawiera bit ważności, \emph{adres rozkazu rozgałęzienia}, bity historii oraz \emph{adres docelowy rozgałęzienia}.},%
isTrue2={Tak},%
answer2={Pozwala zminimalizować liczbę błędnych przewidywań rozgałęzień w zagnieżdżonej pętli},%
explain2={Tak, z tego co wiem jest strategią dynamiczną i najbardziej optymalną ze wszystkich - skończony automat przewidywania rozgałęzień oparty na tej tablicy (z dwoma bitami historii) może być zrealizowany na dwóch bitach.},%
isTrue3={Nie},%
answer3={Nie może być stosowana w procesorach CISC},%
explain3={Ten mechanizm służy zabezpieczeniu przed hazardem, który występuje w przetwarzaniu potokowym, a z tego korzystają zarówno CISC jak i RISC.},%
isTrue4={Nie},%
answer4={Jest obsługiwana przez jądro systemu operacyjnego},%
explain4={Chyba nie, ten mechanizm znajduje się w sprzęcie procesora.},%
}



\question{%
	question={Rozkazy wektorowe}%
}{%
isTrue1={Nie},%
answer1={Nie mogą być wykonywane bez użycia potokowych jednostek arytmetycznych},%
explain1={Mogą. Komputery macierzowe ich nie posiadają i wykonują rozkazy wektorowe sprawnie.},%
isTrue2={Tak},%
answer2={W komputerach wektorowych ich czas wykonania jest wprost proporcjonalny do długości wektora},%
explain2={Tak, na przykładzie rozkazu dodawania wektorów widać, że czas rośnie równomiernie wraz z ilością elementów wektora.\\$t_{w}=t_{start}+(n-1)\times\tau$},%
isTrue3={Tak},%
answer3={Są charakterystyczne dla architektury SIMD},%
explain3={Tak, z niej się zrodziły, tak samo jak m.in. technologie MMX i SSE.},%
isTrue4={Nie},%
answer4={Są rozkazami dwuargumentowymi i w wyniku zawsze dają wektor},%
explain4={Nie, mogą operować na 1 argumencie na przykład. Rozkaz może być też 3 argumentowy, jak rozkaz dodawania VADD. Pierwszym argumentem jest rejestr docelowy, zawartość pozostałych dwóch jest dodana.},%
}


% --- PYTANIE 30
\question{%
	question={Model SIMD}%
}{%
isTrue1={Nie},%
answer1={Był wykorzystywany tylko w procesorach macierzowych},%
explain1={Nie, o niego oparte są również m.in. procesory wektorowe, GPU, technologie MMX oraz SSE. Nie, był również wykorzystywany w komputerach wektorowych, rozszerzeniach SIMD oraz GPU.},%
isTrue2={Tak},%
answer2={Jest wykorzystywany w multimedialnych rozszerzeniach współczesnych procesorów},%
explain2={},%
isTrue3={Tak},%
answer3={Jest wykorzystywany w heterogenicznej architekturze PowerXCell},%
explain3={},%
isTrue4={Tak},%
answer4={Zapewnia wykonanie tej samej operacji na wektorach argumentów},%
explain4={},%
}


\question{%
	question={Przesył komunikatów}%
}{%
isTrue1={Tak},%
answer1={Ma miejsce w systemach MPP},%
explain1={},%
isTrue2={Nie},%
answer2={W systemach MPP II-giej generacji angażuje wszystkie procesory na drodze przesyłu},%
explain2={},%
isTrue3={Tak},%
answer3={Ma miejsce w klastrach},%
explain3={},%
}


\question{%
	question={Cechami wyróżniającymi klastry są}%
}{%
isTrue1={Tak},%
answer1={Niezależność programowa każdego węzła},%
explain1={},%
isTrue2={Nie},%
answer2={Fizycznie rozproszona, ale logicznie wspólna pamięć operacyjna},%
explain2={},%
isTrue3={Nie},%
answer3={Nieduża skalowalność},%
explain3={},%
isTrue4={Tak},%
answer4={Na ogół duża niezawodność},%
explain4={},%
}


\question{%
	question={Systemy wieloprocesorowe z pamięcią rozproszoną}%
}{%
isTrue1={Nie},%
answer1={Wyróżniają się bardzo dużą skalowalnością},%
explain1={},%
isTrue2={Nie},%
answer2={Są budowane z węzłów, którymi są klastry},%
explain2={},%
isTrue3={Tak},%
answer3={Realizują synchronicznie jeden wspólny program},%
explain3={},%
isTrue4={Nie},%
answer4={Wymagają zapewnienia spójności pamięci podręcznych pomiędzy węzłami},%
explain4={},%
}


\question{%
	question={Problemy z potokowym wykonywaniem rozkazów skoków (rozgałęzień) mogą być wyeliminowane lub ograniczone przy pomocy}%
}{%
isTrue1={Nie},%
answer1={Zapewnienia spójności pamięci podręcznej},%
explain1={Nie, to problem komputerów wieloprocesorowych.},%
isTrue2={Tak},%
answer2={Tablicy historii rozgałęzień},%
explain2={Tak, to najprawdopodobniej najlepszy służący ku temu mechanizm. Stara się przewidywać czy skok będzie wykonany bądź nie, wykorzystuje do tego kilka strategii.},%
isTrue3={Nie},%
answer3={Techniki wyprzedzającego pobrania argumentu},%
explain3={Nie, ten mechanizm służy do eliminacji hazardu danych - zależności między argumentami.},%
isTrue4={Tak},%
answer4={Wystawienia do programu rozkazów typu „nic nie rób”},%
explain4={Tak, tym rozkazem jest \emph{NOP} i jest wstawiany przez mechanizm skoków opóźnionych, który służy do zabezpieczania potoku.},%
isTrue5={Nie},%
answer5={Protokołu MESI}, %
explain5={Nie, on jest od zapewnienia spójności pamięci wspólnej czy jakoś tak.}, %
isTrue6={Tak}, %
answer6={Wykorzystania techniki skoków opóźniających}, %
explain6={Tak, umożliwiają ona modyfikację programu (wstawienie rozkazu NOP), albo jego optymalizację (zamiana kolejności wykonywania rozkazów.) Mechanizm ten opóźnia efekt skoku o jeden rozkaz, co zapewnia, że rozkaz po skoku będzie w całości wykonany.}, %
isTrue7={Nie}, %
answer7={Technologii MMX}, %
explain7={}, %
}


% --- PYTANIE 35
\question{%
	question={W architekturze ccNUMA}%
}{%
isTrue1={Tak},%
answer1={Każdy procesor ma dostęp do pamięci operacyjnej każdego węzła},%
explain1={},%
isTrue2={Nie},%
answer2={Spójność pamięci pomiędzy węzłami jest utrzymywana za pomocą protokołu MESI},%
explain2={},%
isTrue3={Tak},%
answer3={Dane są wymieniane między węzłami w postaci linii pamięci podręcznej},%
explain3={},%
isTrue4={Tak},%
answer4={Pamięć operacyjna jest fizycznie rozproszona pomiędzy węzłami, ale wspólna logicznie},%
explain4={},%
}


\question{%
	question={Dla sieci systemowych (SAN) są charakterystyczne}%
}{%
isTrue1={Tak},%
answer1={Przesył komunikatów w trybie zdalnego DMA},%
explain1={},%
isTrue2={Tak},%
answer2={Bardzo małe czasy opóźnień},%
explain2={},%
isTrue3={Nie},%
answer3={Topologia typu hipersześcian},%
explain3={},%
isTrue4={Nie},%
answer4={Niska przepustowość},%
explain4={},%
}


\question{%
	question={W systemach wieloprocesorowych katalog służy do}%
}{%
isTrue1={Nie},%
answer1={Śledzenia adresów w protokole MESI},%
explain1={},%
isTrue2={Nie},%
answer2={Sterowania przesyłem komunikatów},%
explain2={},%
isTrue3={Tak},%
answer3={Utrzymania spójności pamięci w systemach o niejednorodnym dostępie do pamięci},%
explain3={},%
isTrue4={Tak},%
answer4={Realizacji dostępu do nielokalnych pamięci w systemach NUMA},%
explain4={},%
}


\question{%
	question={W procesorach superskalarnych}%
}{%
isTrue1={Tak},%
answer1={Jest możliwe równoległe wykonywanie kilku rozkazów w jednym procesorze (rdzeniu)},%
explain1={Tak, własnie taka jest idea stworzenia procesorów superskalaranych, by móc w jednym takcie wykonać $>1$ liczby instrukcji. Zapewnia to niepojedyncza liczba jednostek potokowych.},%
isTrue2={Tak},%
answer2={Rozszerzenia architektury wykorzystujące model SIMD umożliwiają wykonanie rozkazów wektorowych},%
explain2={},%
isTrue3={Nie},%
answer3={Nie występuje prawdziwa zależność danych},%
explain3={Niestety występuje, i prawdę mówiąc, występuje tutaj każdy rodzaj zależności między rozkazami: prawdziwa zależność danych, zależność wyjściowa oraz antyzależność.},%
isTrue4={Tak},%
answer4={Mogą wystąpić nowe formy hazardu danych: zależności wyjściowe między rozkazami oraz antyzależności},%
explain4={Tak, patrz wyżej.},%
}


\question{%
	question={Efektywne wykorzystanie równoległości na poziomie danych umożliwiają}%
}{%
isTrue1={Tak},%
answer1={Komputery wektorowe},%
explain1={},%
isTrue2={Tak},%
answer2={Komputery macierzowe},%
explain2={},%
isTrue3={Tak},%
answer3={Klastry},%
explain3={},%
isTrue4={Tak},%
answer4={Procesory graficzne},%
explain4={},%
isTrue5={Tak},%
answer5={Rozszerzenia SIMD procesorów superskalarnych}, %
explain5={\\Ogółem zastosowanie tej równoległości jest możliwe gdy mamy do czynienia z wieloma danymi, które mogą być przetwarzane w tym samym czasie. A grafika, wektory, macierze itp. do takich należą.}, %
}


% --- PYTANIE 40
\question{%
	question={Wielowątkowość współbieżna w procesorze wielopotokowym zapewnia}%
}{%
isTrue1={Tak},%
answer1={Możliwość wprowadzenia rozkazów różnych wątków do wielu potoków},%
explain1={Tak, jest to charakterystyczna cecha tego typu wielowątkowości. Z kolei wielowątkowości grubo- i drobnoziarniste umożliwiają wprowadzenie do wielu potoków \emph{wyłącznie} jednego wątku (w jednym takcie!)},%
isTrue2={Tak},%
answer2={Realizację każdego z wątków do momentu wstrzymania któregoś rozkazu z danego wątku},%
explain2={Tak, wątek jest realizowany do momentu wstrzymania rozkazu. Tę samą cechę posiada wielowątkowość gruboziarnista. Z kolei wielowątkowość drobnoziarnista w kolejnych taktach realizuje naprzemiennie rozkazy kolejnych wątków.},%
isTrue3={Nie},%
answer3={Przełączanie wątków co takt},%
explain3={Nie, to umożliwia tylko wielowątkowość drobnoziarnista.},%
isTrue4={Nie},%
answer4={Automatyczne przemianowanie rejestrów},%
explain4={Głowy nie dam, ale chyba żadna wielowątkowość nie zapewnia automatycznego przemianowania.},%
}


\question{%
	question={Architektura CUDA}%
}{%
isTrue1={Tak},%
answer1={Umożliwia bardzo wydajne wykonywanie operacji graficznych},%
explain1={Tak, ta architektura jest rozwinięciem mechanizmów wektorowych oraz macierzowych i jest przeznaczona specjalnie dla przetwarzania grafiki.},%
isTrue2={Tak},%
answer2={Stanowi uniwersalną architekturę obliczeniowa połączoną z równoległym modelem programistycznym},%
explain2={Tak, pomimo specjalizacji graficznej, architektura ta jest uniwersalna i zdolna do wszystkiego. Procesory posiadają uniwersalne programy obliczeniowe, a CUDA posiada model programistyczny (oraz podział programu na 5 faz). Składa się on z:\\- Kompilatora NVCC;\\- Podział programu na kod wykonywany przez procesor (host code) oraz kartę graficzną (kernel);\\- Realizacja obliczeń równoległych wg modelu SIMT (Single Instruction Multiple Threading)},%
isTrue3={Tak},%
answer3={Realizuje model obliczeniowy SIMT},%
explain3={Tak, patrz wyżej. Działanie: wiele niezależnych wątków wykonuje tę samą operację. Architektura posiada również mechanizm synchronizacji wątków (\emph{barrir synchronization}) dla komunikacji oraz współdzielona pamięć.},%
isTrue4={Nie},%
answer4={Jest podstawą budowy samodzielnych, bardzo wydajnych komputerów},%
explain4={Komputery CUDA nie są ogólnego zastosowania, tylko do ogólnych problemów numerycznych. Na pewno nie są podstawą, bo np. komputer ... (dokończyć by trza)},%
}


\question{%
	question={Spójność pamięci podręcznych w procesorze wielordzeniowym może być m.in. zapewniona za pomocą}%
}{%
isTrue1={Nie},%
answer1={Przełącznicy krzyżowej},%
explain1={Nie, to tylko jakieś rozwiązanie sieci połączeń.},%
isTrue2={Nie},%
answer2={Katalogu},%
explain2={ie,to bardziej zaawansowany shit służący do komunikacji.},%
isTrue3={Tak},%
answer3={Protokołu MESI},%
explain3={Tak, i tylko to do tego służy.},%
isTrue4={Nie},%
answer4={Wspólnej magistrali},%
explain4={Nie, ona służy do komunikacji i synchronizacji (?) dostępu do pamięci.},%
}


\question{%
	question={Metoda przemianowania rejestrów jest stosowana w celu eliminacji:}%
}{%
isTrue1={Nie},%
answer1={Błędnego przewidywania rozgałęzień},%
explain1={Nie, do tego służy m.in. tablica historii rozgałęzień.},%
isTrue2={Nie},%
answer2={Chybionego odwołania do pamięci podręcznej},%
explain2={Nie, to jest problem architektury VLIW i eliminuje się do przez przesunięcie rozkazów LOAD jak najwyżej, tak aby zminimalizować czas ewentualnego oczekiwania},%
isTrue3={Nie},%
answer3={Prawdziwej zależności danych},%
explain3={Nie, od tego jest metoda wyprzedzającego pobierania argumentu.},%
isTrue4={Tak},%
answer4={Zależności wyjściowej między rozkazami.},%
explain4={Tak, ta metoda eliminuje powyższy i poniższy problem. Polega na dynamicznym przypisywaniu rejestrów do rozkazów.},%
isTrue5={Tak},%
answer5={Antyzależności między rozkazami},%
explain5={Patrz wyżej.},%
}

\question{%
	question={W systemach wieloprocesorowych o architekturze CC-NUMA}%
}{%
isTrue1={Tak},%
answer1={Spójność pamięci wszystkich węzłów jest utrzymywana za pomocą katalogu},%
explain1={},%
isTrue2={Tak},%
answer2={Pamięć operacyjna jest rozproszona fizycznie pomiędzy węzłami, ale wspólna logicznie},%
explain2={},%
isTrue3={Nie},%
answer3={Każdy procesor ma bezpośredni dostęp do pamięci operacyjnej każdego węzła},%
explain3={},%
isTrue4={Nie},%
answer4={Dane są wymieniane między węzłami w postaci linii pamięci podręcznej},%
explain4={},%
}


% --- PYTANIE 45
\question{%
	question={W tablicy historii rozgałęzień z 1 bitem historii można zastosować następujący algorytm przewidywania (najbardziej złożony)}%
}{%
isTrue1={Nie},%
answer1={Skok opóźniony},%
explain1={Nie, skoki opóźnione nie służą do przewidywania rozgałęzień, są zupełnie innym mechanizmem eliminacji hazardu.},%
isTrue2={Nie},%
answer2={Przewidywanie, że rozgałęzienie (skok warunkowy) zawsze nastąpi},%
explain2={Nie, to strategia statyczna, która może być wykonywana gdy adres rozkazu rozgałęzienia NIE jest w tablicy. Nie wykorzystuje bitu historii.},%
isTrue3={Nie},%
answer3={Przewidywanie, że rozgałęzienie nigdy nie nastąpi},%
explain3={Nie, to strategia statyczna, która może być wykonywana gdy adres rozkazu rozgałęzienia NIE jest w tablicy. Nie wykorzystuje bitu historii.},%
isTrue4={Tak},%
answer4={Przewidywanie, że kolejne wykonanie rozkazu rozgałęzienia będzie przebiegało tak samo jak poprzednie},%
explain4={Tak, i to jest wszystko na co stać historię 1-bitową. Historia 2-bitowa umożliwia interpretację:\\- historii ostatniego wykonania skoku - tak lub nie;\\- przewidywania następnego wykonania skoku - tak lub nie\\A zamiana strategii następuje dopiero po drugim błędzie przewidywania.},%
isTrue5={Nie},%
answer5={Wstrzymanie napełniania potoku}, %
explain5={Nie, wstrzymywanie potoku mogą spowodować algorytmy zajmujące się eliminacją hazardu danych - zależnosci między argumentami.}, %
}

\question{%
	question={Do czynników tworzących wysoką niezawodność klastrów należą}%
}{%
isTrue1={Tak},%
answer1={Mechanizm mirroringu dysków},%
explain1={},%
isTrue2={Tak},%
answer2={Dostęp każdego węzła do wspólnych zasobów(pamięci zewnętrznych)},%
explain2={},%
isTrue3={Tak},%
answer3={Redundancja węzłów},%
explain3={},%
isTrue4={Nie},%
answer4={Mechanizm "heartbeat"},%
explain4={},%
isTrue5={Nie},%
answer5={Zastosowanie procesorów wielordzeniowych w węzłach}, %
explain5={}, %
}




\end{enumerate}